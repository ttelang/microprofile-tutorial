= MicroProfile OpenAPI

:imagesdir: ../../assets/images

== Introduction 

In the previous chapters, you built RESTful APIs that various clients can use to access your web services regardless of programming language or platform. However, clients need a clear and comprehensive contract that describes available endpoints, expected parameters, and response formats to integrate seamlessly with these web services. This need for a well-defined API contract has led to the adoption of the OpenAPI specification.

This chapter introduces MicroProfile OpenAPI and shows you how to document your RESTful services using OpenAPI annotations. You'll learn to generate comprehensive API documentation that follows the OpenAPI specification, then visualize and interact with your documented APIs using Swagger UI (aka Open UI tool), a browser-based interface that makes your API contract immediately accessible to developers and stakeholders.

== Topics to be covered:
- Introduction to MicroProfile OpenAPI
- API Specification using MicroProfile Open API
- Generating API Documentation
- Documenting Authentication and Authorization Requirements
- Exploring the APIs using Swagger UI

=== New Features in MicroProfile OpenAPI 4.1:
  * OpenAPI v3.1 compatibility
  * Java Records support
  * @Target annotation enhancements
  * JSON Schema Dialect support
  * Extensible interface methods
  * Async operations with callbacks
  * Optional<T> nullable fields
  * Comprehensive security schemes

== OpenAPI Specification

The Open API Specification (OAS), formerly known as Swagger, defines a standard format for describing and publishing REST APIs. It provides a language-agnostic interface to RESTful APIs. API providers use OAS to create machine-readable documents that describe their endpoints, request/response schemas, authentication requirements, and other API characteristics. This standardization enables powerful tooling: IDEs can generate client code automatically, testing frameworks can validate your API against its specification, and documentation tools can create interactive API explorers from a single OpenAPI document.

[NOTE]
====
The OpenAPI Initiative, a Linux Foundation collaborative project, maintains the specification. Industry leaders including Google, Microsoft, and Amazon contribute to this community-driven standard, ensuring it meets enterprise requirements while remaining vendor-neutral.
====

By adopting OpenAPI, you create a single source of truth that serves as both human-readable documentation and a machine-parsable contract, simplifying API development, testing, and long-term maintenance while making your API more accessible to consumers.

== Introduction to MicroProfile OpenAPI

The MicroProfile OpenAPI specification integrates OpenAPI Specification (OAS) with Jakarta Restful Web Services, providing Java annotations that automatically generate OpenAPI documentation from your Java code. This annotation-driven approach offers several advantages:

* Documentation stays synchronized with code
* No need to maintain separate specification files  
* OpenAPI output is generated automatically when your application deploys
* Standard Jakarta REST endpoints work without modification

MicroProfile OpenAPI 4.0 supports OpenAPI Specification 3.1, ensuring your APIs are consistent, well-documented, and easily consumable across different development tools, testing frameworks, and API consumers.

== Capabilities of MicroProfile OpenAPI Specification

MicroProfile OpenAPI provides a set of annotations and APIs that allow you to generate OpenAPI 3.1-compliant specifications directly from your Jakarta REST code. Instead of manually writing YAML or JSON specification files, you document your API using Java annotations, and MicroProfile OpenAPI generates the complete specification automatically.

The specification supports the full range of OpenAPI features:

* *Endpoint Documentation*: Describe operations, parameters, request/response schemas, and examples
* *Data Models*: Define reusable schemas for your domain objects
* *Authentication*: Document security requirements and schemes
* *API Metadata*: Specify versioning, contact information, license details, and servers
* *Response Definitions*: Describe success and error responses with status codes

Once generated, your OpenAPI specification enables a rich ecosystem of tools. Documentation portals like Swagger UI create interactive API explorers. Code generators produce client libraries in multiple languages. Testing frameworks validate requests and responses against your specification. Mock servers simulate your API for development and testing.

MicroProfile OpenAPI ensures your documentation stays synchronized with your implementation, eliminating the common problem of outdated API specifications.

== Generating OpenAPI documents

MicroProfile OpenAPI generates documentation primarily through annotations you add to your Jakarta REST resources. This annotation-driven approach keeps your documentation synchronized with your code. When you update an endpoint, you update its documentation at the same time.

=== Annotation-Based Generation

The recommended approach is to annotate your Jakarta REST classes and methods with OpenAPI annotations. MicroProfile OpenAPI scans your application at build time, discovers annotated endpoints, and generates a complete OpenAPI specification automatically.

This approach offers several benefits:
* Documentation lives alongside the code it describes
* IDE support for autocomplete and validation
* Compile-time checking ensures annotations are valid
* No separate specification files to maintain

=== Static OpenAPI Files (Optional)

You can also provide a static OpenAPI document in YAML or JSON format at `META-INF/openapi.yaml` or `META-INF/openapi.json`. MicroProfile OpenAPI will merge this static content with the generated specification, allowing you to:

* Add API-level metadata (title, version, contact info)
* Define reusable schemas or security schemes
* Override generated documentation for specific endpoints

However, for most applications, annotations alone are sufficient.

=== Selective Documentation

Use the `mp.openapi.scan.exclude.packages` and `mp.openapi.scan.exclude.classes` configuration properties to exclude specific resources from documentation. This is useful for internal or administrative endpoints you don't want to expose in your public API specification.

== Using MicroProfile Open API in your project

To use MicroProfile OpenAPI in your project, you need to add the following maven coordinates to your project:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.microprofile.openapi</groupId>
  <artifactId>microprofile-openapi-api</artifactId>
  <version>4.1</version>
  <scope>provided</scope>
</dependency>
----

NOTE: Use `<scope>provided</scope>` since your MicroProfile runtime already includes the implementation.

== Basic Annotation Example 

let's enhance our `ProductResource` class with OpenAPI annotations to generate comprehensive documentation:

[source, java]
----
//... 

@ApplicationScoped
@Path("/products")
@Tag(name = "Products", description = "Product catalog operations")
public class ProductResource {

    //...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
       summary = "List all products", 
       description = "Retrieves a complete list of products in the catalog")
    @APIResponses(value = {
        @APIResponse(
            responseCode = "200",
            description = "Successfully retrieved product list",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = Product.class)
            )
        ),
        @APIResponse(
            responseCode = "500",
            description = "Internal server error"
        )
    })
    public List<Product> getAllProducts() {
        // Method implementation
    }
}
----

Explanation: 

* `@Tag`: Groups related endpoints together in the documentation
* `@Operation`: Provides a summary and description for the `getProducts()` method and is used for descripting what the endpoint does.
* `@APIResponses`: Describes the possible HTTP responses from the `getProducts()` operation. There are two possible responses – a successful response containing a list of produdts with a 200 status code, and an unsuccessful response with a 500 status code, in case of internal server error.
* `@APIResponse`: Defines a specific response with status code and content. In this case, a successful response (HTTP 200) is described, indicating that the method returns an array of Product entities. The `responseCode` field is used to specify the status code of the response, and the `description` field is used to provide a brief description of the response. 
* `@Content`: Specifies the response media type and structure. In this example, the response content is a list of Products.
* `@Schema`: References the data model returned (in this case, `Product.class`)

These annotations enrich the `ProductResource` class with metadata necessary for generating comprehensive and descriptive OpenAPI documentation automatically.

Finally, we need to add the following property to the src/main/resources/META-INF/microprofile-config.properties file:

----
mp.openapi.scan=true
----

This property tells MicroProfile OpenAPI to scan our classes for annotations and generate API documentation for them. 

Now that we have configured MicroProfile OpenAPI, we can build and run our application.

== How to view the generated documentation

To view the generated documentation, we can use the OpenAPI UI tool. The Open API UI tool is a web-based tool that can be used to view the documentation for a REST API.

The OpenAPI UI tool can be accessed at the following URL:

----
http://<hostname>:<port>/openapi/
----

Replace `<hostname>` and `<port>` with the actual hostname and port used by your runtime, for e.g. localhost:9080 which is the default port at Open Liberty server. 

The `/openapi` endpoint is used to get information about the OpenAPI specification generated from the comments in the source code annotations. It returns information in YAML format.

When we access the `http://localhost:9080/openapi` URL, we should see the API documentation that was generated by MicroProfile OpenAPI:

[source, yaml]
---
openapi: 3.1.0
components:
  schemas:
    Product:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
        description:
          type: string
        price:
          type: number
          format: double
info:
  title: Generated API
  version: "1.0"
paths:
  /api/products:
    get:
      summary: List all products
      description: Retrieves a complete list of products in the catalog.
      tags:
      - Products
      responses:
        "200":
          description: Successfully retrieved product list
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Product'
        "500":
          description: Internal server error
tags:
- name: Products
  description: Product catalog operations
servers:
- url: https://localhost:5050/mp-ecomm-store
---

As we can see, MicroProfile OpenAPI has generated API documentation for our resource class. We can use this documentation to learn about the API and how to use it. This documentation includes the following information:

* The `/products` endpoint description
* The GET operation summary and details  
* Expected response codes (200, 500)
* The JSON structure of the Product response
* Grouping under the "Products" tag

MicroProfile OpenAPI allows developers to produce these specifications directly from their codebase, leveraging annotations and/or providing OpenAPI documents statically. This direct generation ensures that the API documentation is always up to date with the code.

This specification can then be visualized in Swagger UI, consumed by client generators, or used by testing frameworks.

== Exploring the APIs using Swagger UI

To open Swagger UI for the API documentation generated using MicroProfile OpenAPI, you will need to deploy your application to a server that supports MicroProfile, such as Open Liberty, WildFly, Quarkus, or Payara Micro. These servers automatically generate the OpenAPI documentation for your RESTful services based on the annotations in your code. 

Next, visit the following URL to launch the Swagger UI: 

----
http://localhost:9080/openapi/ui
----

Swagger UI is then used to render this documentation in a user-friendly web interface. Below is the screenshot of swagger UI for the Product REST Resource. 

:figure-caption: Swagger UI 
.Swagger UI
image::figure4-1.png[MicroProfile OpenAPI]

== Annotations 

The MicroProfile OpenAPI annotations can be used to document any Jakarta Restful Web Services resource. The annotations can also be used in conjunction with other Jakarta Restful Webservices annotations, such as @Path and @Produces. The most common annotations that are used to document RESTful web services are list in Table 4-1.

[cols="1,3", options="header"]
|===
| Annotations | Details

| @OpenAPIDefinition
| Provides metadata about the entire API. It can include information such as the title, description, version, terms of service, and contact information.

| @Info 
| Used inside @OpenAPIDefinition to provide API metadata like title, version, description.

| @Contact
| Specifies contact information for the API, used within @Info.

| @License 
| Defines the license information for the API, also used within @Info.

| @Operation
| Describes a single API operation on a resource.

| @APIResponse
| It is used to document a response from an operation.

| @APIResponses
| A container for multiple @APIResponse annotations, allowing documentation of different responses for a single API operation.

| @RequestBody
| Describes the request body of an HTTP request, specifying the content of the body and whether it is required.

| @Schema
| Provides schema details for a response or request body, specifying the data type, format, and constraints.

| @Parameter
| Provides information on parameters to the operation, including query parameters, header parameters, and path parameters.

| @Tag
| Adds metadata to a single tag that is used by the Operation. It helps in categorizing operations by resources or any other qualifier.

| @Content 
| Specifies the media type and schema of the operation's request or response body.

| @Components 
| Allows the definition of reusable components such as schemas, responses, parameters, and more, which can be referenced by other annotations.

| @SecurityRequirement
| Specifies a security requirement for an operation, referencing security schemes defined in the @Components.

| @ExternalDocumentation
| Provides additional external documentation for an API or operation.

| @Callback
| Specifies a callback URL for an asynchronous operation.

| @Callbacks
| Specifies multiple `@Callback` annotations.

| @Server 
| Describes a server that hosts the API, specifying URL and description, which can be global or specific to operations or paths

|===

All of these annotations are defined in the org.eclipse.microprofile.openapi.annotations package.

== New Features in MicroProfile OpenAPI 4.1

MicroProfile OpenAPI 4.1 introduces several enhancements that improve developer productivity and align with the OpenAPI v3.1 specification. These features simplify API documentation, add support for modern Java language features, and provide better schema validation capabilities.

=== OpenAPI v3.1 Specification Support

MicroProfile OpenAPI 4.1 fully supports the OpenAPI v3.1 specification, which brings several important improvements:

==== JSON Schema 2020-12 Alignment

OpenAPI v3.1 adopts JSON Schema 2020-12 as its schema vocabulary, replacing the custom JSON Schema dialect used in v3.0. This provides:

* Valid JSON Schema documents that work with standard validators
* Better interoperability with JSON Schema tooling and libraries
* Access to newer JSON Schema features like `prefixItems`, `$dynamicRef`, and enhanced pattern properties

You can now use standard JSON Schema validation tools to test your API schemas independently of OpenAPI tooling.

==== Improved Nullable Type Handling

OpenAPI v3.1 eliminates the proprietary `nullable: true` in favor of JSON Schema's standard approach using type arrays `(type: ["string", "null"])`

*Before (OpenAPI v3.0):*
[source, yaml]
----
schema:
  type: string
  nullable: true  # Custom OpenAPI extension
----

*Now (OpenAPI v3.1):*
[source, yaml]
----
schema:
  type: ["string", "null"]  # Standard JSON Schema
----

When documenting query parameters, path parameters, or request body fields that can be null, MicroProfile OpenAPI 4.1 generates OpenAPI v3.1 specifications that use standard JSON Schema nullable notation (type: ["string", "null"]) instead of the deprecated `nullable: true` keyword.

==== Enhanced Schema Composition

OpenAPI v3.1 provides improved support for `oneOf`, `anyOf`, and `allOf` keywords, enabling more flexible and precise schema modeling for:

* Polymorphic types (using discriminators)
* Union types (multiple possible schemas)
* Inheritance relationships (schema extension and composition)

=== Support for Java Records

Java Records (introduced in Java 14/16) provide a concise way to declare immutable data carriers with several advantages:

* *Concise syntax*: Requires less boilerplate code compared to traditional POJOs (Plain Old Java Objects)
* *Immutability*: Records are inherently immutable, hence promoting safer API contracts
* *Type safety*: Records provides compile-time guarantees for your data models
* *Clarity of intent*: Records signal that the type is a simple data carrier

MicroProfile OpenAPI 4.1 provides native support for Java Records, automatically generating schema definitions from record components.

==== Basic Record Schema Generation

MicroProfile OpenAPI automatically discovers record components and generates corresponding OpenAPI schemas. Here's an example using a category record for organizing products:

*Java Record definition:*
[source, java]
----
// ... 

@Schema(name = "CategoryRecord", description = "Product category information")
public record CategoryRecord(
    @NotNull
    @Schema(description = "Category ID", example = "1")
    Long id,
    
    @NotNull
    @Schema(description = "Category name", example = "Electronics")
    String name,
    
    @Schema(description = "Parent category ID for hierarchical structure", nullable = true)
    Long parentId,
    
    @NotNull
    @Schema(description = "Display order", example = "1")
    Integer displayOrder
) {}
----

The generated OpenAPI schema for the record:

[source, yaml]
----
openapi: 3.1.0
components:
  schemas:
    CategoryRecord:
      description: Product category information
      type: object
      required:
      - id
      - name
      - displayOrder
      properties:
        id:
          type: integer
          format: int64
          description: Category ID
          examples:
          - 1
        name:
          type: string
          description: Category name
          examples:
          - Electronics
        parentId:
          type:
          - integer
          - "null"
          format: int64
          description: Parent category ID for hierarchical structure
        displayOrder:
          type: integer
          format: int32
          description: Display order
          examples:
          - 1
----

Use `@NotNull` validation annotations or `@Schema(required = true)` to explicitly mark components as required in the generated specification. For nullable components, you can either use `@Schema(nullable = true)` or wrap the type in `Optional<T>` to indicate they can accept null values. In this example, `@NotNull` annotations mark `id`, `name`, and `displayOrder` as required, while `parentId` is marked as nullable for root categories that have no parent.

=== Enhanced Annotation Type Safety

MicroProfile OpenAPI 4.1 improves type safety by adding explicit `@Target` meta-annotations to several OpenAPI annotations. This enhancement works behind the scenes to help IDEs and build tools provide better warnings when annotations are used in inappropriate locations.

==== What This Means for Developers

The `@Target` meta-annotation defines where an annotation can be applied (classes, methods, fields, parameters, etc.). Prior to MicroProfile OpenAPI 4.1, some annotations lacked explicit `@Target` definitions, making it harder for development tools to validate annotation usage.

With MicroProfile OpenAPI 4.1, annotations like `@Schema`, `@SchemaProperty`, and others now have explicit `@Target` constraints that:

* Provide warnings for incorrect annotation usage
* Help build tools detect potential issues during compilation
* Make the API more predictable and self-documenting
* Improve code completion accuracy in modern IDEs

==== Example: Compile-Time Warnings for Incorrect Usage

You would get a compile time warning about improper annotation placement:

*Incorrect usage:*
[source, java]
----
@Schema(description = "Product resource")  // warning: unusual location for @Schema
@Path("/products")
public class ProductResource {
    // While this compiles, the @Schema annotation on the resource class itself
    // may not have the intended effect
}
----

*Recommended usage:*
[source, java]
----
@Path("/products")
public class ProductResource {
    
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "Get all products")
    @APIResponse(
        responseCode = "200",
        content = @Content(schema = @Schema(implementation = Product.class))
    )
    public List<Product> getAllProducts() {
        return productService.findAll();
    }
}
----

==== Working with Flexible Schema Types

The enhanced type safety works seamlessly with flexible schema definitions:

*Example: Product with dynamic attributes*
[source, java]
----
package io.microprofile.tutorial.store.product.entity;

import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.enums.SchemaType;
import java.util.Map;
import java.util.List;
import lombok.Data;

@Data
@Schema(
    description = "Product with flexible custom attributes",
    properties = {
        @SchemaProperty(name = "tags")
    }
)   // Valid on TYPE
public class FlexibleProduct {
    
    @Schema(description = "Product ID", example = "1")  // Valid on FIELD
    private Long id;
    
    @Schema(description = "Product name", example = "Wireless Mouse")
    private String name;
    
    @Schema(description = "Product price", example = "29.99")
    private Double price;
    
    @Schema(
        description = "Product specifications (e.g., color, material, size)",
        type = SchemaType.OBJECT,
        example = "{\"color\": \"black\", \"material\": \"plastic\", \"weight\": \"100g\"}"
    )
    private Map<String, Object> specifications;
    
    @Schema(
        description = "Product tags for categorization and search",
        type = SchemaType.ARRAY,
        implementation = String.class,
        example = "[\"wireless\", \"electronics\", \"accessories\"]"
    )
    private List<String> tags;
}
----

The `@SchemaProperty` annotation allows you to reference properties at the class level, particularly useful when combined with field-level `@Schema` annotations.

*Generated OpenAPI schema:*
[source, yaml]
----
FlexibleProduct:
      description: Product with flexible custom attributes
      properties:
        tags:
          description: Product tags for categorization and search
          type: array
          examples:
          - - wireless
            - electronics
            - accessories
          items:
            type: string
        id:
          type: integer
          format: int64
          description: Product ID
          examples:
          - 1
        name:
          type: string
          description: Product name
          examples:
          - Wireless Mouse
        price:
          type: number
          format: double
          description: Product price
          examples:
          - 29.99
        specifications:
          type: object
          additionalProperties: {}
          description: "Product specifications (e.g., color, material, size)"
          examples:
          - color: black
            material: plastic
            weight: 100g
      type: object
----

==== Benefits of Enhanced Type Safety

The addition of explicit `@Target` annotations provides:

* *Early error detection*: Misused annotations are caught at compile time, not runtime
* *Better IDE experience*: Code completion only suggests annotations valid for the current context
* *Self-documenting API*: Annotation definitions clearly communicate their intended use
* *Reduced debugging time*: Fewer runtime errors related to incorrect annotation placement
* *More maintainable code*: Clear constraints make it easier for teams to use annotations correctly

=== JSON Schema Dialect Support

MicroProfile OpenAPI 4.1 introduces the `jsonSchemaDialect` property, which allows you to specify which JSON Schema dialect is used in your OpenAPI document. This property is part of OpenAPI 3.1's alignment with JSON Schema standards.

==== Understanding JSON Schema Dialects

A JSON Schema dialect defines which version and vocabulary of JSON Schema is being used. OpenAPI 3.1 supports multiple dialects:

* *Default dialect*: `https://spec.openapis.org/oas/3.1/dialect/base` - The standard OpenAPI 3.1 JSON Schema dialect
* *Full JSON Schema*: `https://json-schema.org/draft/2020-12/schema` - Complete JSON Schema 2020-12 specification
* *Custom dialects*: Organization-specific or tool-specific schema vocabularies

Setting the dialect explicitly ensures compatibility with tools and validators that support specific JSON Schema versions.

==== Specifying the Dialect Programmatically

You can set the JSON Schema dialect using the `OASModelReader` interface:

[source, java]
----
package io.microprofile.tutorial.store.config;

import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASModelReader;
import org.eclipse.microprofile.openapi.models.OpenAPI;

public class CustomModelReader implements OASModelReader {
    
    @Override
    public OpenAPI buildModel() {
        return OASFactory.createOpenAPI()
            .openapi("3.1.0")
            // Use default OpenAPI 3.1 dialect (recommended for most use cases)
            .jsonSchemaDialect("https://spec.openapis.org/oas/3.1/dialect/base")
            
            // Alternative: Use full JSON Schema 2020-12 dialect for advanced features
            // .jsonSchemaDialect("https://json-schema.org/draft/2020-12/schema")
            
            .info(OASFactory.createInfo()
                .title("Product Catalog API")
                .version("1.0.0")
                .description("API for managing products in the e-commerce store"));
    }
}
----

The full JSON Schema 2020-12 dialect enables advanced features like:

* `prefixItems` for tuple validation
* `$dynamicRef` and `$dynamicAnchor` for dynamic schema references
* `unevaluatedProperties` and `unevaluatedItems` for strict validation
* Enhanced pattern properties and additional vocabulary extensions

==== Activating the Model Reader

Configure the model reader in `microprofile-config.properties`:

[source, properties]
----
mp.openapi.model.reader=io.microprofile.tutorial.store.config.CustomModelReader
----

==== Dialect Usage

While you can set the `jsonSchemaDialect` programmatically through the OpenAPI model, the dialect property controls how JSON Schema validation and processing occurs internally. The dialect setting ensures that:

* Schema validation follows the specified JSON Schema version rules
* Type definitions are interpreted according to the dialect's vocabulary
* Schema composition keywords (`oneOf`, `anyOf`, `allOf`) behave according to the dialect specification
* Nullable types use the appropriate representation for the dialect
* Advanced JSON Schema features are available when using the full 2020-12 dialect

==== When to Specify the Dialect

You should explicitly set the `jsonSchemaDialect` when:

* *Using advanced JSON Schema features*: `prefixItems`, `$dynamicRef`, `unevaluatedProperties`
* *Integrating with external validators*: Tools that require JSON Schema 2020-12 compliance
* *Strict schema validation*: Need features like `unevaluatedProperties` for comprehensive validation
* *Tool compatibility*: Working with schema generators or validators that expect specific dialects
* *Custom vocabularies*: Using organization-specific schema extensions

For most applications using standard MicroProfile OpenAPI features, the default dialect (`https://spec.openapis.org/oas/3.1/dialect/base`) is used automatically and doesn't need to be explicitly set.

==== Comparison of Dialects

.JSON Schema Dialect Feature Comparison
[options="header"]
|===
|Feature | Description | OpenAPI 3.1 Base Dialect |Full JSON Schema 2020-12

|*Basic Validation*
|Basic type validation (`string`, `number`, `boolean`, etc.)
|✓ Supported
|✓ Supported

|*Schema Composition*
|Combining schemas using `oneOf`, `anyOf`, `allOf`
|✓ Supported
|✓ Supported

|*Nullable Types*
|Representing values that can be `null`
|✓ Supported with type arrays
|✓ Supported with type arrays

|*Tuple Validation (`prefixItems`)*
|Validate arrays with different types per position (e.g., [`string`, `number`, `boolean`])
|✗ Not available
|✓ Supported

|*Dynamic References (`$dynamicRef`)*
|Advanced schema composition with runtime-resolved references
|✗ Not available
|✓ Supported

|*Strict Validation (`unevaluatedProperties`)*
|Reject additional properties not covered by schema
|✗ Not available
|✓ Supported

|*Custom Vocabularies (`$vocabulary`)*
|Define and use custom validation keywords
|✗ Not available
|✓ Supported

|*Primary Use Case*
|
|Standard REST API documentation and validation
|Advanced schema validation, tooling integration, strict compliance

|*Recommended For*
|
|Most microservices and REST APIs
|Complex validation requirements, schema tooling, external validators
|===

=== Extensible Interface Methods

MicroProfile OpenAPI 4.1 adds two new methods to the `Extensible` interface: `getExtension(String)` and `hasExtension(String)`. These methods provide a more convenient way to work with vendor extensions in your OpenAPI model.

Example: Using the new Extensible interface methods

[source, java]
----
import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.Operation;

public class ExtensionFilter implements OASFilter {
    
    @Override
    public Operation filterOperation(Operation operation) {
        // Check if a custom extension exists
        if (operation.hasExtension("x-custom-timeout")) {
            Object timeout = operation.getExtension("x-custom-timeout");
            System.out.println("Custom timeout found: " + timeout);
            
            // Modify based on the extension
            if (timeout != null && (Integer) timeout > 30) {
                operation.addExtension("x-requires-approval", true);
            }
        }
        return operation;
    }
}
----

Adding extensions to an operation:

[source, java]
----
@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Operation(
    summary = "Get product by ID",
    extensions = {
        @Extension(name = "x-custom-timeout", value = "60"),
        @Extension(name = "x-rate-limit", value = "100")
    }
)
public Response getProductById(@PathParam("id") Long id) {
    // Method implementation
}
----

=== Using @Operation for Async Methods

MicroProfile OpenAPI 4.1 supports documenting asynchronous operations using the `@Operation` annotation in combination with callbacks. This is particularly useful for webhook-style APIs or operations that trigger asynchronous processing.

Example: Documenting an async operation with callbacks

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.callbacks.Callback;
import org.eclipse.microprofile.openapi.annotations.callbacks.CallbackOperation;
import org.eclipse.microprofile.openapi.annotations.parameters.RequestBody;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

@POST
@Path("/async-process")
@Operation(
    summary = "Process product asynchronously",
    description = "Initiates async product processing and calls back when complete"
)
@Callback(
    name = "productProcessed",
    callbackUrlExpression = "{$request.body#/callbackUrl}",
    operations = {
        @CallbackOperation(
            method = "post",
            summary = "Product processing completed",
            requestBody = @RequestBody(
                content = @Content(
                    mediaType = "application/json",
                    schema = @Schema(implementation = ProcessResult.class)
                )
            )
        )
    }
)
public Response processProductAsync(
    @RequestBody(
        description = "Product and callback URL",
        content = @Content(
            mediaType = "application/json",
            schema = @Schema(implementation = AsyncRequest.class)
        )
    ) AsyncRequest request
) {
    // Initiate async processing
    return Response.accepted().build();
}

// Supporting classes
public static class AsyncRequest {
    private Product product;
    private String callbackUrl;
    // Getters and setters
}

public static class ProcessResult {
    private Long productId;
    private String status;
    private String message;
    // Getters and setters
}
----

=== Using Optional<T> Fields as Nullable

MicroProfile OpenAPI 4.1, with its alignment to OpenAPI v3.1, provides better handling of Java's `Optional<T>` type. Fields declared as `Optional<T>` are automatically treated as nullable in the generated schema.

Example: Using Optional fields

[source, java]
----
import java.util.Optional;
import org.eclipse.microprofile.openapi.annotations.media.Schema;

@Schema(description = "Product with optional fields")
public class ProductWithOptional {
    
    @Schema(description = "Product ID", required = true)
    private Long id;
    
    @Schema(description = "Product name", required = true)
    private String name;
    
    @Schema(description = "Optional product description")
    private Optional<String> description;
    
    @Schema(description = "Optional product category")
    private Optional<String> category;
    
    @Schema(description = "Product price", required = true)
    private Double price;
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Optional<String> getDescription() { return description; }
    public void setDescription(Optional<String> description) { 
        this.description = description; 
    }
    
    public Optional<String> getCategory() { return category; }
    public void setCategory(Optional<String> category) { 
        this.category = category; 
    }
    
    public Double getPrice() { return price; }
    public void setPrice(Double price) { this.price = price; }
}
----

The generated schema correctly identifies optional fields as nullable:

[source, yaml]
----
components:
  schemas:
    ProductWithOptional:
      description: Product with optional fields
      required:
        - id
        - name
        - price
      type: object
      properties:
        id:
          description: Product ID
          type: integer
          format: int64
        name:
          description: Product name
          type: string
        description:
          description: Optional product description
          type: 
            - string
            - null
        category:
          description: Optional product category
          type:
            - string
            - null
        price:
          description: Product price
          type: number
          format: double
----

=== Using Security Schemes in OpenAPI Documentation

Security is a critical aspect of API documentation. MicroProfile OpenAPI 4.1 provides comprehensive support for documenting various security schemes including API keys, HTTP authentication, OAuth2, and OpenID Connect.

Example: Defining security schemes

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.OpenAPIDefinition;
import org.eclipse.microprofile.openapi.annotations.security.SecurityScheme;
import org.eclipse.microprofile.openapi.annotations.security.SecuritySchemes;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeType;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeIn;
import org.eclipse.microprofile.openapi.annotations.security.OAuthFlows;
import org.eclipse.microprofile.openapi.annotations.security.OAuthFlow;
import org.eclipse.microprofile.openapi.annotations.security.OAuthScope;
import org.eclipse.microprofile.openapi.annotations.info.Info;
import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/api")
@OpenAPIDefinition(
    info = @Info(
        title = "Secured Product API",
        version = "1.0.0",
        description = "Product API with multiple security schemes"
    )
)
@SecuritySchemes({
    @SecurityScheme(
        securitySchemeName = "apiKey",
        type = SecuritySchemeType.APIKEY,
        description = "API Key authentication",
        in = SecuritySchemeIn.HEADER,
        apiKeyName = "X-API-Key"
    ),
    @SecurityScheme(
        securitySchemeName = "bearerAuth",
        type = SecuritySchemeType.HTTP,
        description = "JWT Bearer token authentication",
        scheme = "bearer",
        bearerFormat = "JWT"
    ),
    @SecurityScheme(
        securitySchemeName = "oauth2",
        type = SecuritySchemeType.OAUTH2,
        description = "OAuth2 authentication",
        flows = @OAuthFlows(
            authorizationCode = @OAuthFlow(
                authorizationUrl = "https://example.com/oauth/authorize",
                tokenUrl = "https://example.com/oauth/token",
                scopes = {
                    @OAuthScope(name = "read:products", description = "Read product information"),
                    @OAuthScope(name = "write:products", description = "Modify product information")
                }
            )
        )
    )
})
public class SecuredProductApplication extends Application {
}
----

Applying security to specific operations:

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirements;

@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Operation(summary = "Get product by ID", description = "Requires authentication")
@SecurityRequirement(name = "bearerAuth")
@APIResponse(
    responseCode = "200",
    description = "Product found",
    content = @Content(
        mediaType = "application/json",
        schema = @Schema(implementation = Product.class)
    )
)
@APIResponse(responseCode = "401", description = "Unauthorized")
@APIResponse(responseCode = "404", description = "Product not found")
public Response getSecuredProduct(@PathParam("id") Long id) {
    // Method implementation
}

@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Operation(summary = "Create a new product", description = "Requires OAuth2 write scope")
@SecurityRequirement(name = "oauth2", scopes = {"write:products"})
@APIResponse(
    responseCode = "201",
    description = "Product created",
    content = @Content(
        mediaType = "application/json",
        schema = @Schema(implementation = Product.class)
    )
)
@APIResponse(responseCode = "401", description = "Unauthorized")
@APIResponse(responseCode = "403", description = "Forbidden - insufficient scopes")
public Response createSecuredProduct(Product product) {
    // Method implementation
}
----

The generated OpenAPI document includes comprehensive security information:

[source, yaml]
----
openapi: 3.1.0
info:
  title: Secured Product API
  version: 1.0.0
  description: Product API with multiple security schemes
components:
  securitySchemes:
    apiKey:
      type: apiKey
      description: API Key authentication
      name: X-API-Key
      in: header
    bearerAuth:
      type: http
      description: JWT Bearer token authentication
      scheme: bearer
      bearerFormat: JWT
    oauth2:
      type: oauth2
      description: OAuth2 authentication
      flows:
        authorizationCode:
          authorizationUrl: https://example.com/oauth/authorize
          tokenUrl: https://example.com/oauth/token
          scopes:
            read:products: Read product information
            write:products: Modify product information
paths:
  /api/products/{id}:
    get:
      summary: Get product by ID
      description: Requires authentication
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Product found
        "401":
          description: Unauthorized
        "404":
          description: Product not found
  /api/products:
    post:
      summary: Create a new product
      description: Requires OAuth2 write scope
      security:
        - oauth2:
            - write:products
      responses:
        "201":
          description: Product created
        "401":
          description: Unauthorized
        "403":
          description: Forbidden - insufficient scopes
----

== Summary

By integrating MicroProfile OpenAPI 4.1, developers can generate detailed, OpenAPI v3.1-compliant documentation automatically, fostering better understanding and interaction among services. The new features in version 4.1, including enhanced support for Java Records, improved handling of Optional types, JSON Schema dialect specification, and comprehensive security scheme documentation, make it easier than ever to create robust, well-documented APIs.

MicroProfile OpenAPI 4.1's alignment with OpenAPI v3.1 ensures that your API documentation leverages the latest standards in the API ecosystem. By annotating your `ProductResource` class and utilizing the new capabilities such as the Extensible interface methods, @Target annotations, and async operation support, you can generate comprehensive API documentation that ensures your services are readily discoverable, understandable, and usable. This accelerates development cycles and fosters a more robust and collaborative developer ecosystem.
