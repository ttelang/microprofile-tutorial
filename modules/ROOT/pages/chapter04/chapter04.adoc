= MicroProfile OpenAPI

:imagesdir: ../../assets/images

== Introduction 

In the previous chapter, we saw how RESTful APIs facilitate language-agnostic access to web services from diverse environments. However, a clear and comprehensive contract is required to ensure seamless integration between clients and services. This need for a well-defined API contract has led to the adoption of the OpenAPI specification.
This chapter will explore the primary features of MicroProfile OpenAPI, demonstrate how to integrate it into your MicroProfile applications, and show you how to annotate your RESTful services to produce rich documentation that adheres to the OpenAPI specification. Furthermore, we will introduce the OpenAPI UI, a visual interface allowing developers and stakeholders to interact with and visualize the documented APIs, enhancing understanding and facilitating integration.


== Topics to be covered:
- Introduction to MicroProfile OpenAPI
- API Specification using MicroProfile Open API
- Generating API Documentation
- Documenting Authentication and Authorization Requirements
- Exploring the APIs using Swagger UI
- New Features in MicroProfile OpenAPI 4.1:
  * OpenAPI v3.1 compatibility
  * Java Records support
  * @Target annotation enhancements
  * JSON Schema Dialect support
  * Extensible interface methods
  * Async operations with callbacks
  * Optional<T> nullable fields
  * Comprehensive security schemes

== OpenAPI Specification

The Open API Specification (OAS), formerly Swagger specification, is a technical specification that allows REST API providers to describe and publish their APIs using a format that various tools can consume. It defines a standard, language-agnostic interface to RESTful APIs, making it easy for third-party tools to generate documentation, client SDKs, and a range of tools that promote the seamless consumption of RESTful APIs.

NOTE: The OpenAPI Initiative, a consortium of industry experts committed to standardizing how to describe REST APIs, maintains the OpenAPI Specification. It is a community-driven initiative, and many large organizations use it, including Google, Microsoft, and Amazon.

The OpenAPI specification enables creation of a well-defined, clear and comprehensive API contract. It provides a standardized way to describe the API's structure, expected requests and responses, and authentication mechanisms, making it easier to develop, test, and maintain RESTful APIs.

== Introduction to MicroProfile OpenAPI

The MicroProfile OpenAPI specification builds upon the widely recognized OpenAPI Specification (OAS) and leverages annotations from the Jakarta Restful Web Services specification. The primary focus of MicroProfile OpenAPI is on defining REST APIs that utilize JSON within the context of HTTP.

The specification aims to provide a uniform way of describing APIs so that they are both human-readable and machine-readable.  It facilitates the creation of APIs that are consistent, well-documented, and easily consumable by both humans and machines. 

== Capabilities of MicroProfile OpenAPI Specification

MicroProfile OpenAPI provides a suite of Java APIs that allows developers to define and generate API specifications that adhere to OpenAPI v3.1 standards. As a result, it simplifies the process of designing, documenting, and publishing RESTful APIs for developers. 

Developers can quickly generate documentation for their microservices using MicroProfile OpenAPI. The documentation includes information on what services are provided, how to invoke them, and what data types are used. It generates comprehensive metadata about services, ensuring interoperability across diverse platforms and tools. Also, documentation can generate client code to access the web services.

The OpenAPI Specification fuels a rich ecosystem of tools that automate and support. This specification streamlines the creation of OpenAPI documentation for RESTful services using a unified approach. It generates comprehensive metadata about services, ensuring interoperability across diverse platforms and tools:

* *API Documentation Generation*: Intuitive interactive documentation portals emerge directly from the specification.
* *Client SDK Creation*: Client libraries in various languages can be automatically generated.
* *API Testing*: Testing frameworks can leverage the specification to design robust tests.
* *API Mocking*: Simplifies mocking APIs for testing and development purposes.

== Generating OpenAPI documents

There are multiple ways in which you can generate OpenAPI documents. The most common way is to use annotations. This only requires augmenting your Jakarta Restful Web Services annotations with OpenAPI annotations. 

Besides annotations, a predefined OpenAPI document may be provided in either YAML or JSON format. This so-called static model will be merged with the model generated by scanning for Jakarta REST endpoints and the combined result will be made available to clients. However, the annotation-based approach is recommended as it is more maintainable and easier to understand. Finally, you can filter out the resources you do not want to document using configuration.

== Using MicroProfile Open API in your project

To document Jakarta RESTful Web Services using MicroProfile OpenAPI, we need to annotate the resource classes and methods with the OpenAPI annotation. 

To use MicroProfile OpenAPI in your project, you need to add the following maven coordinates to your project:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.microprofile.openapi</groupId>
  <artifactId>microprofile-openapi-api</artifactId>
  <version>4.1</version>
</dependency>
----

Below is an illustrative example of how you might annotate a method in the `ProductResource` class to achieve this documentation using MicroProfile OpenAPI annotations:

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@ApplicationScoped
@Path("/products")
@Tag(name = "Product Resource", description = "CRUD operations for products")
public class ProductResource {

    //...

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(summary = "List all products", description = "Retrieves a list of all available products")
    @APIResponses(value = {
        @APIResponse(
            responseCode = "200",
            description = "Successful, list of products found",
            content = @Content(mediaType = "application/json",
                    schema = @Schema(implementation = Product.class))
        ),
        @APIResponse(
            responseCode = "400",
            description = "Unsuccessful, no products found",
            content = @Content(mediaType = "application/json")
        )
    })
    public List<Product> getAllProducts() {
        // Method implementation
    }
}
----

Explanation: 

* `@Operation`: Provides a summary and description for the `getProducts()` method.

* `@APIResponse`: Describes the possible responses from the `getProducts()` operation. In this case, a successful response (HTTP 200) is described, indicating that the method returns an array of Product entities.

* `@Schema`: Specifies the schema of the response content. Here, it is used to indicate that the method returns an array of Product objects.

These annotations enrich the `ProductResource` class with metadata necessary for generating comprehensive and descriptive OpenAPI documentation automatically.

We have also annotated the `getProducts()` method with the @APIResponse annotation to document the successful response from the operation. The `responseCode` field is used to specify the status code of the response, and the `description` field is used to provide a brief description of the response. There are two possible responses â€“ a successful response containing a list of produdts with a 200 status code, and an unsuccessful response with a 400 status code, if no products are found. The content field is used to specify the schema of the response content. In this example, the response content is a list of `Product`s.

Finally, we need to add the following property to the src/main/resources/META-INF/microprofile-config.properties file:

----
mp.openapi.scan=true
----

This property tells MicroProfile OpenAPI to scan our classes for annotations and generate API documentation for them. 

Now that we have configured MicroProfile OpenAPI, we can build and run our application.

== How to view the generated documentation

To view the generated documentation, we can use the OpenAPI UI tool. The Open API UI tool is a web-based tool that can be used to view the documentation for a REST API.

The OpenAPI UI tool can be accessed at the following URL:

----
http://localhost:<port>/openapi/
----

Replace `<port>` with the actual port used by your runtime, for e.g. 9080 which is the default port at Open Liberty server. 

The `/openapi` endpoint is used to get information about the OpenAPI specification generated from the comments in the source code annotations. It returns information in YAML format.

When we access the `http://localhost:5050/openapi` URL, we should see the API documentation that was generated by MicroProfile OpenAPI:

[source, yaml]
----
openapi: 3.1.0
info:
  title: Generated API
  version: "1.0"
servers:
- url: http://localhost:9080/catalog
paths:
  /api/products:
    get:
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Product'
    put:
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Product'
      responses:
        "200":
          description: OK
    post:
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Product'
      responses:
        "200":
          description: OK
  /api/products/products/{id}:
    delete:
      parameters:
      - name: id
        in: path
        required: true
        schema:
          format: int64
          type: integer
      responses:
        "200":
          description: OK
  /api/products/{id}:
    get:
      parameters:
      - name: id
        in: path
        required: true
        schema:
          format: int64
          type: integer
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Product'
components:
  schemas:
    Product:
      required:
      - name
      - description
      - price
      type: object
      properties:
        id:
          format: int64
          type: integer
        name:
          type: string
        description:
          type: string
        price:
          format: double
          type: number
----

As we can see, MicroProfile OpenAPI has generated API documentation for our resource class. We can use this documentation to learn about the API and how to use it. 

MicroProfile OpenAPI allows developers to produce these specifications directly from their codebase, leveraging annotations and/or providing OpenAPI documents statically. This direct generation ensures that the API documentation is always up to date with the code.

== Exploring the APIs using Swagger UI

To open Swagger UI for the API documentation generated using MicroProfile OpenAPI, you will need to deploy your application to a server that supports MicroProfile, such as Open Liberty, WildFly, Quarkus, or Payara Micro. These servers automatically generate the OpenAPI documentation for your RESTful services based on the annotations in your code. 

Next, visit the following URL to launch the Swagger UI: 

----
http://localhost:9080/openapi/ui
----

Swagger UI is then used to render this documentation in a user-friendly web interface. Below is the screenshot of swagger UI for the Product REST Resource. 

:figure-caption: Swagger UI 
.Swagger UI
image::figure4-1.png[MicroProfile OpenAPI]

== Annotations 

The MicroProfile OpenAPI annotations can be used to document any Jakarta Restful Web Services resource. The annotations can also be used in conjunction with other Jakarta Restful Webservices annotations, such as @Path and @Produces. The most common annotations that are used to document RESTful web services are list in Table 4-1.

[cols="1,3", options="header"]
|===
| Annotations | Details

| @OpenAPIDefinition
| Provides metadata about the entire API. It can include information such as the title, description, version, terms of service, and contact information.

| @Info 
| Used inside @OpenAPIDefinition to provide API metadata like title, version, description.

| @Contact
| Specifies contact information for the API, used within @Info.

| @License 
| Defines the license information for the API, also used within @Info.

| @Operation
| Describes a single API operation on a resource.

| @APIResponse
| It is used to document a response from an operation.

| @APIResponses
| A container for multiple @APIResponse annotations, allowing documentation of different responses for a single API operation.

| @RequestBody
| Describes the request body of an HTTP request, specifying the content of the body and whether it is required.

| @Schema
| Provides schema details for a response or request body, specifying the data type, format, and constraints.

| @Parameter
| Provides information on parameters to the operation, including query parameters, header parameters, and path parameters.

| @Tag
| Adds metadata to a single tag that is used by the Operation. It helps in categorizing operations by resources or any other qualifier.

| @Content 
| Specifies the media type and schema of the operation's request or response body.

| @Components 
| Allows the definition of reusable components such as schemas, responses, parameters, and more, which can be referenced by other annotations.

| @SecurityRequirement
| Specifies a security requirement for an operation, referencing security schemes defined in the @Components.

| @ExternalDocumentation
| Provides additional external documentation for an API or operation.

| @Callback
| Specifies a callback URL for an asynchronous operation.

| @Callbacks
| Specifies multiple `@Callback` annotations.

| @Server 
| Describes a server that hosts the API, specifying URL and description, which can be global or specific to operations or paths

|===

All of these annotations are defined in the org.eclipse.microprofile.openapi.annotations package.

== New Features in MicroProfile OpenAPI 4.1

MicroProfile OpenAPI 4.1 introduces several significant enhancements that align with the OpenAPI v3.1 specification and improve developer productivity. This section explores the key features introduced in version 4.1.

=== Compatibility with OpenAPI v3.1

MicroProfile OpenAPI 4.1 is fully compatible with the OpenAPI v3.1 specification, which brings several improvements over the previous version:

* *JSON Schema 2020-12 Support*: OpenAPI v3.1 aligns with JSON Schema 2020-12, providing more robust schema validation and better interoperability with JSON Schema tools.

* *Improved nullable handling*: In OpenAPI v3.1, nullable types are represented using JSON Schema's type arrays (e.g., `type: ["string", "null"]`) instead of the deprecated `nullable` keyword.

* *Enhanced Schema composition*: Better support for `oneOf`, `anyOf`, and `allOf` for more flexible schema modeling.

Example of OpenAPI v3.1 output:

[source, yaml]
----
openapi: 3.1.0
info:
  title: Product API
  version: "1.0"
paths:
  /api/products:
    get:
      responses:
        "200":
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Product'
----

=== Support for Java Records

Java Records, introduced in Java 14 and finalized in Java 16, provide a concise way to declare immutable data carriers. MicroProfile OpenAPI 4.1 provides enhanced support for Java Records, automatically generating appropriate schema definitions for record types.

Example: Using Java Records with MicroProfile OpenAPI

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.media.Schema;

@Schema(name = "ProductRecord", description = "Product information as a Java Record")
public record ProductRecord(
    @Schema(description = "Product ID", example = "1")
    Long id,
    
    @Schema(description = "Product name", example = "Laptop", required = true)
    String name,
    
    @Schema(description = "Product description", example = "High-performance laptop")
    String description,
    
    @Schema(description = "Product price", example = "999.99", required = true)
    Double price
) {}
----

Using the record in a REST resource:

[source, java]
----
@GET
@Path("/record/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Operation(summary = "Get product as record", description = "Returns product data using Java Record")
@APIResponse(
    responseCode = "200", 
    description = "Product found",
    content = @Content(
        mediaType = "application/json",
        schema = @Schema(implementation = ProductRecord.class)
    )
)
public ProductRecord getProductRecord(@PathParam("id") Long id) {
    Product product = productService.findProductById(id);
    return new ProductRecord(product.getId(), product.getName(), 
                            product.getDescription(), product.getPrice());
}
----

The generated OpenAPI schema for the record:

[source, yaml]
----
components:
  schemas:
    ProductRecord:
      description: Product information as a Java Record
      required:
        - name
        - price
      type: object
      properties:
        id:
          description: Product ID
          type: integer
          format: int64
          example: 1
        name:
          description: Product name
          type: string
          example: Laptop
        description:
          description: Product description
          type: string
          example: High-performance laptop
        price:
          description: Product price
          type: number
          format: double
          example: 999.99
----

=== @Target Annotation Enhancement

MicroProfile OpenAPI 4.1 adds proper `@Target` annotations to several schema-related annotations, improving type safety and IDE support. The annotations `@DependentRequired`, `@DependentSchema`, and `@SchemaProperty` now have explicit target definitions.

Example: Using @DependentRequired and @DependentSchema

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.media.DependentRequired;
import org.eclipse.microprofile.openapi.annotations.media.DependentSchema;
import org.eclipse.microprofile.openapi.annotations.media.SchemaProperty;

@Schema(
    description = "Product with conditional validation",
    dependentRequired = {
        @DependentRequired(
            name = "discount",
            requires = {"discountReason"}
        )
    }
)
public class ConditionalProduct {
    private Long id;
    private String name;
    private Double price;
    private Double discount;
    private String discountReason;
    
    // Getters and setters
}
----

This ensures that if a `discount` field is provided, the `discountReason` field must also be included in the request.

=== JSON Schema Dialect Support

MicroProfile OpenAPI 4.1 introduces the `jsonSchemaDialect` property, which allows you to specify which JSON Schema dialect is used in your OpenAPI document. This is particularly useful when working with tools that require specific JSON Schema versions.

Example: Using jsonSchemaDialect programmatically

[source, java]
----
import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASModelReader;
import org.eclipse.microprofile.openapi.models.OpenAPI;

public class CustomModelReader implements OASModelReader {
    
    @Override
    public OpenAPI buildModel() {
        return OASFactory.createOpenAPI()
            .openapi("3.1.0")
            .jsonSchemaDialect("https://spec.openapis.org/oas/3.1/dialect/base")
            .info(OASFactory.createInfo()
                .title("Product API")
                .version("1.0.0")
                .description("API for managing products"));
    }
}
----

The resulting OpenAPI document will include:

[source, yaml]
----
openapi: 3.1.0
jsonSchemaDialect: https://spec.openapis.org/oas/3.1/dialect/base
info:
  title: Product API
  version: 1.0.0
  description: API for managing products
----

=== Extensible Interface Methods

MicroProfile OpenAPI 4.1 adds two new methods to the `Extensible` interface: `getExtension(String)` and `hasExtension(String)`. These methods provide a more convenient way to work with vendor extensions in your OpenAPI model.

Example: Using the new Extensible interface methods

[source, java]
----
import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.Operation;

public class ExtensionFilter implements OASFilter {
    
    @Override
    public Operation filterOperation(Operation operation) {
        // Check if a custom extension exists
        if (operation.hasExtension("x-custom-timeout")) {
            Object timeout = operation.getExtension("x-custom-timeout");
            System.out.println("Custom timeout found: " + timeout);
            
            // Modify based on the extension
            if (timeout != null && (Integer) timeout > 30) {
                operation.addExtension("x-requires-approval", true);
            }
        }
        return operation;
    }
}
----

Adding extensions to an operation:

[source, java]
----
@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Operation(
    summary = "Get product by ID",
    extensions = {
        @Extension(name = "x-custom-timeout", value = "60"),
        @Extension(name = "x-rate-limit", value = "100")
    }
)
public Response getProductById(@PathParam("id") Long id) {
    // Method implementation
}
----

=== Using @Operation for Async Methods

MicroProfile OpenAPI 4.1 supports documenting asynchronous operations using the `@Operation` annotation in combination with callbacks. This is particularly useful for webhook-style APIs or operations that trigger asynchronous processing.

Example: Documenting an async operation with callbacks

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.callbacks.Callback;
import org.eclipse.microprofile.openapi.annotations.callbacks.CallbackOperation;
import org.eclipse.microprofile.openapi.annotations.parameters.RequestBody;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;

@POST
@Path("/async-process")
@Operation(
    summary = "Process product asynchronously",
    description = "Initiates async product processing and calls back when complete"
)
@Callback(
    name = "productProcessed",
    callbackUrlExpression = "{$request.body#/callbackUrl}",
    operations = {
        @CallbackOperation(
            method = "post",
            summary = "Product processing completed",
            requestBody = @RequestBody(
                content = @Content(
                    mediaType = "application/json",
                    schema = @Schema(implementation = ProcessResult.class)
                )
            )
        )
    }
)
public Response processProductAsync(
    @RequestBody(
        description = "Product and callback URL",
        content = @Content(
            mediaType = "application/json",
            schema = @Schema(implementation = AsyncRequest.class)
        )
    ) AsyncRequest request
) {
    // Initiate async processing
    return Response.accepted().build();
}

// Supporting classes
public static class AsyncRequest {
    private Product product;
    private String callbackUrl;
    // Getters and setters
}

public static class ProcessResult {
    private Long productId;
    private String status;
    private String message;
    // Getters and setters
}
----

=== Using Optional<T> Fields as Nullable

MicroProfile OpenAPI 4.1, with its alignment to OpenAPI v3.1, provides better handling of Java's `Optional<T>` type. Fields declared as `Optional<T>` are automatically treated as nullable in the generated schema.

Example: Using Optional fields

[source, java]
----
import java.util.Optional;
import org.eclipse.microprofile.openapi.annotations.media.Schema;

@Schema(description = "Product with optional fields")
public class ProductWithOptional {
    
    @Schema(description = "Product ID", required = true)
    private Long id;
    
    @Schema(description = "Product name", required = true)
    private String name;
    
    @Schema(description = "Optional product description")
    private Optional<String> description;
    
    @Schema(description = "Optional product category")
    private Optional<String> category;
    
    @Schema(description = "Product price", required = true)
    private Double price;
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Optional<String> getDescription() { return description; }
    public void setDescription(Optional<String> description) { 
        this.description = description; 
    }
    
    public Optional<String> getCategory() { return category; }
    public void setCategory(Optional<String> category) { 
        this.category = category; 
    }
    
    public Double getPrice() { return price; }
    public void setPrice(Double price) { this.price = price; }
}
----

The generated schema correctly identifies optional fields as nullable:

[source, yaml]
----
components:
  schemas:
    ProductWithOptional:
      description: Product with optional fields
      required:
        - id
        - name
        - price
      type: object
      properties:
        id:
          description: Product ID
          type: integer
          format: int64
        name:
          description: Product name
          type: string
        description:
          description: Optional product description
          type: 
            - string
            - "null"
        category:
          description: Optional product category
          type:
            - string
            - "null"
        price:
          description: Product price
          type: number
          format: double
----

=== Using Security Schemes in OpenAPI Documentation

Security is a critical aspect of API documentation. MicroProfile OpenAPI 4.1 provides comprehensive support for documenting various security schemes including API keys, HTTP authentication, OAuth2, and OpenID Connect.

Example: Defining security schemes

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.OpenAPIDefinition;
import org.eclipse.microprofile.openapi.annotations.security.SecurityScheme;
import org.eclipse.microprofile.openapi.annotations.security.SecuritySchemes;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeType;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeIn;
import org.eclipse.microprofile.openapi.annotations.security.OAuthFlows;
import org.eclipse.microprofile.openapi.annotations.security.OAuthFlow;
import org.eclipse.microprofile.openapi.annotations.security.OAuthScope;
import org.eclipse.microprofile.openapi.annotations.info.Info;
import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/api")
@OpenAPIDefinition(
    info = @Info(
        title = "Secured Product API",
        version = "1.0.0",
        description = "Product API with multiple security schemes"
    )
)
@SecuritySchemes({
    @SecurityScheme(
        securitySchemeName = "apiKey",
        type = SecuritySchemeType.APIKEY,
        description = "API Key authentication",
        in = SecuritySchemeIn.HEADER,
        apiKeyName = "X-API-Key"
    ),
    @SecurityScheme(
        securitySchemeName = "bearerAuth",
        type = SecuritySchemeType.HTTP,
        description = "JWT Bearer token authentication",
        scheme = "bearer",
        bearerFormat = "JWT"
    ),
    @SecurityScheme(
        securitySchemeName = "oauth2",
        type = SecuritySchemeType.OAUTH2,
        description = "OAuth2 authentication",
        flows = @OAuthFlows(
            authorizationCode = @OAuthFlow(
                authorizationUrl = "https://example.com/oauth/authorize",
                tokenUrl = "https://example.com/oauth/token",
                scopes = {
                    @OAuthScope(name = "read:products", description = "Read product information"),
                    @OAuthScope(name = "write:products", description = "Modify product information")
                }
            )
        )
    )
})
public class SecuredProductApplication extends Application {
}
----

Applying security to specific operations:

[source, java]
----
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirements;

@GET
@Path("/{id}")
@Produces(MediaType.APPLICATION_JSON)
@Operation(summary = "Get product by ID", description = "Requires authentication")
@SecurityRequirement(name = "bearerAuth")
@APIResponse(
    responseCode = "200",
    description = "Product found",
    content = @Content(
        mediaType = "application/json",
        schema = @Schema(implementation = Product.class)
    )
)
@APIResponse(responseCode = "401", description = "Unauthorized")
@APIResponse(responseCode = "404", description = "Product not found")
public Response getSecuredProduct(@PathParam("id") Long id) {
    // Method implementation
}

@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Operation(summary = "Create a new product", description = "Requires OAuth2 write scope")
@SecurityRequirement(name = "oauth2", scopes = {"write:products"})
@APIResponse(
    responseCode = "201",
    description = "Product created",
    content = @Content(
        mediaType = "application/json",
        schema = @Schema(implementation = Product.class)
    )
)
@APIResponse(responseCode = "401", description = "Unauthorized")
@APIResponse(responseCode = "403", description = "Forbidden - insufficient scopes")
public Response createSecuredProduct(Product product) {
    // Method implementation
}
----

The generated OpenAPI document includes comprehensive security information:

[source, yaml]
----
openapi: 3.1.0
info:
  title: Secured Product API
  version: 1.0.0
  description: Product API with multiple security schemes
components:
  securitySchemes:
    apiKey:
      type: apiKey
      description: API Key authentication
      name: X-API-Key
      in: header
    bearerAuth:
      type: http
      description: JWT Bearer token authentication
      scheme: bearer
      bearerFormat: JWT
    oauth2:
      type: oauth2
      description: OAuth2 authentication
      flows:
        authorizationCode:
          authorizationUrl: https://example.com/oauth/authorize
          tokenUrl: https://example.com/oauth/token
          scopes:
            read:products: Read product information
            write:products: Modify product information
paths:
  /api/products/{id}:
    get:
      summary: Get product by ID
      description: Requires authentication
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Product found
        "401":
          description: Unauthorized
        "404":
          description: Product not found
  /api/products:
    post:
      summary: Create a new product
      description: Requires OAuth2 write scope
      security:
        - oauth2:
            - write:products
      responses:
        "201":
          description: Product created
        "401":
          description: Unauthorized
        "403":
          description: Forbidden - insufficient scopes
----

== Summary

By integrating MicroProfile OpenAPI 4.1, developers can generate detailed, OpenAPI v3.1-compliant documentation automatically, fostering better understanding and interaction among services. The new features in version 4.1, including enhanced support for Java Records, improved handling of Optional types, JSON Schema dialect specification, and comprehensive security scheme documentation, make it easier than ever to create robust, well-documented APIs.

MicroProfile OpenAPI 4.1's alignment with OpenAPI v3.1 ensures that your API documentation leverages the latest standards in the API ecosystem. By annotating your `ProductResource` class and utilizing the new capabilities such as the Extensible interface methods, @Target annotations, and async operation support, you can generate comprehensive API documentation that ensures your services are readily discoverable, understandable, and usable. This accelerates development cycles and fosters a more robust and collaborative developer ecosystem.
